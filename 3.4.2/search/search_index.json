{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Overview","text":"<p>Eclipse Vert.x is the leading toolkit for writing reactive applications on the JVM.</p> <p>While the Vert.x core APIs expose asynchronous programming through callbacks and promise / future, code generators offer bindings to other asynchronous programming models, including: Kotlin coroutines, and RxJava 1, 2 and 3.</p> <p>This project offers Vert.x binding for Mutiny, an intuitive event-driven reactive programming library for Java.</p>"},{"location":"#getting-the-bindings","title":"Getting the bindings","text":"<p>The bindings can be accessed from the following Maven coordinates:</p> <ul> <li>Group: <code>io.smallrye.reactive</code></li> <li>Artifact: <code>smallrye-mutiny-vertx-&lt;MODULE&gt;</code> where <code>MODULE</code> refers to a Vert.x module, such as <code>core</code>, <code>pg-client</code>, <code>web-client</code>, etc.</li> </ul> <p>The Mutiny bindings are modular</p> <p>If you are familiar with other Vert.x bindings such as those for RxJava then you need to be aware that the Mutiny bindings are offered on a per-module basis. For instance the RxJava 3 bindings are exposed through the <code>io.vertx:vertx-rx-java3</code> dependency, and that <code>vertx-rx-java3</code> has optional dependencies on the whole Vert.x stack. We think that it is cleaner to offer bindings on a per-module basis, so your project does not have optional dependencies on modules of the Vert.x stack that you don't consume.</p> <p>The full list of supported modules from the Vert.x stack is available at https://github.com/smallrye/smallrye-mutiny-vertx-bindings/tree/main/vertx-mutiny-clients</p>"},{"location":"#a-short-example","title":"A short example","text":"<p>The following self-contained JBang script shows some of the features of the Vert.x Mutiny bindings (see the highlights):</p> <pre><code>///usr/bin/env jbang \"$0\" \"$@\" ; exit $?\n//DEPS io.smallrye.reactive:smallrye-mutiny-vertx-core:2.6.0\n\nimport io.smallrye.mutiny.Uni;\nimport io.smallrye.mutiny.vertx.core.AbstractVerticle;\nimport io.vertx.core.DeploymentOptions;\nimport io.vertx.mutiny.core.Vertx;\n\npublic class hello {\n\nstatic class MyVerticle extends AbstractVerticle {\n\nprivate long counter = 0L;\n\n/*\n         * Asynchronous start completion notification through a Uni.\n         * This is the Mutiny variant of `start(Promise&lt;Void&gt;)` in plain Vert.x.\n         */\n@Override\npublic Uni&lt;Void&gt; asyncStart() {\n/* \n             * Vert.x stream (ticks every 2 seconds) to Mutiny stream (Multi),\n             * then increment a counter.\n             */\nvertx.periodicStream(2000L)\n.toMulti()\n.subscribe().with(tick -&gt; counter++);\n\n/*\n             * HTTP endpoint, where `listen` returns a `Uni&lt;HttpServer&gt;`.\n             * Notifies of the start procedure completion by replacing and\n             * returning the`Uni&lt;HttpServer&gt;` by `Uni&lt;Void&gt;`.\n             */\nreturn vertx.createHttpServer()\n.requestHandler(req -&gt; req.response().endAndForget(\"@\" + counter))\n.listen(8080)\n.onItem()\n.invoke(() -&gt; System.out.println(\"See http://127.0.0.1:8080\"))\n.onFailure()\n.invoke(Throwable::printStackTrace)\n.replaceWithVoid();\n}\n}\n\n/*\n     * Main method, deploys a verticle and awaits for the completion with\n     * an `*AndAwait()` method.\n     */\npublic static void main(String... args) {\nvar vertx = Vertx.vertx();\nSystem.out.println(\"Deployment Starting\");\nvertx.deployVerticleAndAwait(MyVerticle::new, new DeploymentOptions());\nSystem.out.println(\"Deployment completed\");\n}\n}\n</code></pre> <p>This script can be run with <code>./hello.java</code> or <code>jbang run hello.java</code>, and exposes a HTTP server on port 8080:</p> <pre><code>$ ./hello.java\n[jbang] Building jar...\nDeployment Starting\nSee http://127.0.0.1:8080\nDeployment completed\n</code></pre> <p>The HTTP server responds to any HTTP request with the current value of a counter that is incremented every 2 seconds:</p> <pre><code>$ http :8080\nHTTP/1.1 200 OK\ncontent-length: 2\n\n@1\n\n$ http :8080\nHTTP/1.1 200 OK\ncontent-length: 2\n\n@2\n</code></pre> <p>The deployed verticle uses the Mutiny API, where the <code>start(Promise&lt;Void&gt;)</code> method is replaced by <code>asyncStart()</code> method that returns a <code>Uni&lt;Void&gt;</code>. The code also shows how to convert Vert.x streams into Mutiny <code>Multi</code> streams, and how to await for the verticle deployment to complete.</p>"},{"location":"api-translation/","title":"API translation","text":"<p>The Vert.x Mutiny bindings are generated from the existing Vert.x APIs.</p>"},{"location":"api-translation/#vertx-and-asynchronous-operation-methods","title":"Vert.x and asynchronous operation methods","text":"<p>Vert.x is a toolkit that simplifies asynchronous I/O programming. The Vert.x APIs rely on simple conventions to denote methods doing asynchronous operations:</p> <ol> <li>methods that accept a callback as a last parameter, and</li> <li>methods that return a Vert.x <code>Future</code>.</li> </ol> <p>Vert.x has historically relied on callbacks, as in:</p> <pre><code>public void someOperation(Foo a, Bar b, Baz c, Handler&lt;AsyncResult&lt;T&gt;&gt; handler) {\n// (...)\n}\n</code></pre> <p>Here <code>someOperation</code> is a method where <code>a</code>, <code>b</code> and <code>c</code> are parameters, and <code>handler</code> is a callback:</p> <ul> <li>the callback is notified when the asynchronous operation done in <code>someOperation</code> completes (continuation), and</li> <li>callbacks are always passed as a last parameter of type <code>Handler&lt;AsyncResult&lt;T&gt;&gt;</code>, and</li> <li><code>AsyncResult</code> encapsulates an asynchronous result of type <code>T</code>, or a failure.</li> </ul> <p>Since Vert.x 4 asynchronous operations can also be defined by returning a <code>Future&lt;T&gt;</code>, as in:</p> <pre><code>public Future&lt;T&gt; someOperation(Foo a, Bar b, Baz c) {\n// (...)\n}\n</code></pre> <p>Code generators (e.g., Mutiny, RxJava, Kotlin coroutines, etc) can spot these methods and derive their own shim APIs.</p> <p>For instance with Mutiny <code>someOperation</code> becomes:</p> <pre><code>public Uni&lt;T&gt; someOperation(Foo a, Bar b, Baz c) {\n// (...)\n}\n</code></pre>"},{"location":"api-translation/#what-does-the-mutiny-code-generator-do","title":"What does the Mutiny code generator do?","text":"<p>The code generator is applied to selected modules from the Vert.x stack.</p> <p>The translation rules are the following.</p> Rule Translation <code>io.vertx</code> package <code>io.vertx.mutiny</code> package Asynchronous method A method returning a <code>Uni&lt;T&gt;</code> <code>ReadStreams&lt;T&gt;</code> Consumed as a <code>Multi&lt;T&gt;</code> <code>WriteStreams&lt;T&gt;</code> Consumed as a Reactive Streams <code>Subscriber&lt;T&gt;</code> <p>Because Mutiny is a Reactive Streams compliant implementation, the generated shims also adapt the Vert.x back-pressure protocol to that of Reactive Streams.</p> <p>Method erasure</p> <p>The Mutiny code generator erases methods. Given an asynchronous method <code>foo(Handler&lt;AsyncResult&lt;T&gt;&gt;)</code>, then it is not present in the generated shim as it is replaced with <code>Uni&lt;T&gt; foo()</code>.</p>"},{"location":"api-translation/#helper-methods","title":"Helper methods","text":"<p>Given an asynchronous operation method, the Mutiny code generator also provides 2 further variants:</p> <ul> <li><code>xAndAwait()</code> to block the caller thread until the outcome is received, or throw a <code>RuntimeException</code> when a failure arises, and</li> <li><code>xAndForget()</code> to trigger the operation then discard the outcome (failures will be logged).</li> </ul> <p>Given the <code>someOperation</code> method above, the generator provides these 3 methods:</p> <pre><code>// The canonical Mutiny method\npublic Uni&lt;T&gt; someOperation(Foo a, Bar b, Baz c) {\n// (...)\n}\n\n// Blocks, may throw a RuntimeException\npublic T someOperationAndAwait(Foo a, Bar b, Baz c) {\n// (...)\n}\n\n// Does not block, the result or failure is discarded\npublic void someOperationAndForget(Foo a, Bar b, Baz c) {\n// (...), \n}\n</code></pre>"},{"location":"api-translation/#generate-mutiny-variants-from-your-own-apis","title":"Generate Mutiny variants from your own APIs","text":"<p>Vert.x uses an open code generator, so you can generate Mutiny APIs for your own asynchronous interfaces.</p> <p>The code generator is available from the <code>io.smallrye.reactive:vertx-mutiny-generator</code> artifact. It works with the Vert.x <code>io.vertx:vertx-codegen</code> annotation processor.</p> <p>You can generate bindings by having the  artifacts on the classpath for annotation processing at compilation time, or you may use other ways in your builds. The code for this project shows how to generate the files using Maven plugins.</p>"}]}