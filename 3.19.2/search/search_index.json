{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Overview","text":"<p>Eclipse Vert.x is the leading toolkit for writing reactive applications on the JVM.</p> <p>While the Vert.x core APIs expose asynchronous programming through callbacks and promise / future, code generators offer bindings to other asynchronous programming models, including: Kotlin coroutines, and RxJava 1, 2 and 3.</p> <p>This project offers Vert.x binding for Mutiny, an intuitive event-driven reactive programming library for Java.</p>"},{"location":"#getting-the-bindings","title":"Getting the bindings","text":"<p>The bindings can be accessed from the following Maven coordinates:</p> <ul> <li>Group: <code>io.smallrye.reactive</code></li> <li>Artifact: <code>smallrye-mutiny-vertx-&lt;MODULE&gt;</code> where <code>MODULE</code> refers to a Vert.x module, such as <code>core</code>, <code>pg-client</code>, <code>web-client</code>, etc.</li> </ul> <p>The Mutiny bindings are modular</p> <p>If you are familiar with other Vert.x bindings such as those for RxJava then you need to be aware that the Mutiny bindings are offered on a per-module basis. For instance the RxJava 3 bindings are exposed through the <code>io.vertx:vertx-rx-java3</code> dependency, and that <code>vertx-rx-java3</code> has optional dependencies on the whole Vert.x stack. We think that it is cleaner to offer bindings on a per-module basis, so your project does not have optional dependencies on modules of the Vert.x stack that you don't consume.</p> <p>The full list of supported modules from the Vert.x stack is available at https://github.com/smallrye/smallrye-mutiny-vertx-bindings/tree/main/vertx-mutiny-clients</p>"},{"location":"#a-short-example","title":"A short example","text":"<p>The following self-contained JBang script shows some of the features of the Vert.x Mutiny bindings (see the highlights):</p> <pre><code>///usr/bin/env jbang \"$0\" \"$@\" ; exit $?\n//DEPS io.smallrye.reactive:smallrye-mutiny-vertx-core:2.6.0\n\nimport io.smallrye.mutiny.Uni;\nimport io.smallrye.mutiny.vertx.core.AbstractVerticle;\nimport io.vertx.core.DeploymentOptions;\nimport io.vertx.mutiny.core.Vertx;\n\npublic class hello {\n\n    static class MyVerticle extends AbstractVerticle {\n\n        private long counter = 0L;\n\n        /*\n         * Asynchronous start completion notification through a Uni.\n         * This is the Mutiny variant of `start(Promise&lt;Void&gt;)` in plain Vert.x.\n         */\n        @Override\n        public Uni&lt;Void&gt; asyncStart() {\n\n            /* \n             * Vert.x stream (ticks every 2 seconds) to Mutiny stream (Multi),\n             * then increment a counter.\n             */\n            vertx.periodicStream(2000L)\n                .toMulti()\n                .subscribe().with(tick -&gt; counter++);\n\n            /*\n             * HTTP endpoint, where `listen` returns a `Uni&lt;HttpServer&gt;`.\n             * Notifies of the start procedure completion by replacing and\n             * returning the`Uni&lt;HttpServer&gt;` by `Uni&lt;Void&gt;`.\n             */\n            return vertx.createHttpServer()\n                .requestHandler(req -&gt; req.response().endAndForget(\"@\" + counter))\n                .listen(8080)\n                .onItem()\n                    .invoke(() -&gt; System.out.println(\"See http://127.0.0.1:8080\"))\n                .onFailure()\n                    .invoke(Throwable::printStackTrace)\n                .replaceWithVoid();\n        }\n    }\n\n    /*\n     * Main method, deploys a verticle and awaits for the completion with\n     * an `*AndAwait()` method.\n     */\n    public static void main(String... args) {\n        var vertx = Vertx.vertx();\n        System.out.println(\"Deployment Starting\");\n        vertx.deployVerticleAndAwait(MyVerticle::new, new DeploymentOptions());\n        System.out.println(\"Deployment completed\");\n    }\n}\n</code></pre> <p>This script can be run with <code>./hello.java</code> or <code>jbang run hello.java</code>, and exposes a HTTP server on port 8080:</p> <pre><code>$ ./hello.java\n[jbang] Building jar...\nDeployment Starting\nSee http://127.0.0.1:8080\nDeployment completed\n</code></pre> <p>The HTTP server responds to any HTTP request with the current value of a counter that is incremented every 2 seconds:</p> <pre><code>$ http :8080\nHTTP/1.1 200 OK\ncontent-length: 2\n\n@1\n\n$ http :8080\nHTTP/1.1 200 OK\ncontent-length: 2\n\n@2\n</code></pre> <p>The deployed verticle uses the Mutiny API, where the <code>start(Promise&lt;Void&gt;)</code> method is replaced by <code>asyncStart()</code> method that returns a <code>Uni&lt;Void&gt;</code>. The code also shows how to convert Vert.x streams into Mutiny <code>Multi</code> streams, and how to await for the verticle deployment to complete.</p>"},{"location":"api-translation/","title":"API translation","text":"<p>The Vert.x Mutiny bindings are generated from the existing Vert.x APIs.</p>"},{"location":"api-translation/#vertx-and-asynchronous-operation-methods","title":"Vert.x and asynchronous operation methods","text":"<p>Vert.x is a toolkit that simplifies asynchronous I/O programming. The Vert.x APIs rely on simple conventions to denote methods doing asynchronous operations:</p> <ol> <li>methods that accept a callback as a last parameter, and</li> <li>methods that return a Vert.x <code>Future</code>.</li> </ol> <p>Vert.x has historically relied on callbacks, as in:</p> <pre><code>public void someOperation(Foo a, Bar b, Baz c, Handler&lt;AsyncResult&lt;T&gt;&gt; handler) {\n    // (...)\n}\n</code></pre> <p>Here <code>someOperation</code> is a method where <code>a</code>, <code>b</code> and <code>c</code> are parameters, and <code>handler</code> is a callback:</p> <ul> <li>the callback is notified when the asynchronous operation done in <code>someOperation</code> completes (continuation), and</li> <li>callbacks are always passed as a last parameter of type <code>Handler&lt;AsyncResult&lt;T&gt;&gt;</code>, and</li> <li><code>AsyncResult</code> encapsulates an asynchronous result of type <code>T</code>, or a failure.</li> </ul> <p>Since Vert.x 4 asynchronous operations can also be defined by returning a <code>Future&lt;T&gt;</code>, as in:</p> <pre><code>public Future&lt;T&gt; someOperation(Foo a, Bar b, Baz c) {\n    // (...)\n}\n</code></pre> <p>Code generators (e.g., Mutiny, RxJava, Kotlin coroutines, etc) can spot these methods and derive their own shim APIs.</p> <p>For instance with Mutiny <code>someOperation</code> becomes:</p> <pre><code>public Uni&lt;T&gt; someOperation(Foo a, Bar b, Baz c) {\n    // (...)\n}\n</code></pre>"},{"location":"api-translation/#what-does-the-mutiny-code-generator-do","title":"What does the Mutiny code generator do?","text":"<p>The code generator is applied to selected modules from the Vert.x stack.</p> <p>The translation rules are the following.</p> Rule Translation <code>io.vertx</code> package <code>io.vertx.mutiny</code> package Asynchronous method A method returning a <code>Uni&lt;T&gt;</code> <code>ReadStreams&lt;T&gt;</code> Consumed as a <code>Multi&lt;T&gt;</code> <code>WriteStreams&lt;T&gt;</code> Consumed as a Reactive Streams <code>Subscriber&lt;T&gt;</code> <p>Because Mutiny is a Reactive Streams compliant implementation, the generated shims also adapt the Vert.x back-pressure protocol to that of Reactive Streams.</p> <p>Method erasure</p> <p>The Mutiny code generator erases methods. Given an asynchronous method <code>foo(Handler&lt;AsyncResult&lt;T&gt;&gt;)</code>, then it is not present in the generated shim as it is replaced with <code>Uni&lt;T&gt; foo()</code>.</p>"},{"location":"api-translation/#helper-methods","title":"Helper methods","text":"<p>Given an asynchronous operation method, the Mutiny code generator also provides 2 further variants:</p> <ul> <li><code>xAndAwait()</code> to block the caller thread until the outcome is received, or throw a <code>RuntimeException</code> when a failure arises, and</li> <li><code>xAndForget()</code> to trigger the operation then discard the outcome (failures will be logged).</li> </ul> <p>Given the <code>someOperation</code> method above, the generator provides these 3 methods:</p> <pre><code>// The canonical Mutiny method\npublic Uni&lt;T&gt; someOperation(Foo a, Bar b, Baz c) {\n    // (...)\n}\n\n// Blocks, may throw a RuntimeException\npublic T someOperationAndAwait(Foo a, Bar b, Baz c) {\n    // (...)\n}\n\n// Does not block, the result or failure is discarded\npublic void someOperationAndForget(Foo a, Bar b, Baz c) {\n    // (...), \n}\n</code></pre>"},{"location":"api-translation/#generate-mutiny-variants-from-your-own-apis","title":"Generate Mutiny variants from your own APIs","text":"<p>Vert.x uses an open code generator, so you can generate Mutiny APIs for your own asynchronous interfaces.</p> <p>The code generator is available from the <code>io.smallrye.reactive:vertx-mutiny-generator</code> artifact. It works with the Vert.x <code>io.vertx:vertx-codegen</code> annotation processor.</p> <p>You can generate bindings by having the  artifacts on the classpath for annotation processing at compilation time, or you may use other ways in your builds. The code for this project shows how to generate the files using Maven plugins.</p>"},{"location":"using-vertx-expectations/","title":"Using Vert.x expectations","text":"<p>Vert.x <code>Future</code> support expectations as predicates on the resolved values.</p> <p>A good example of pre-defined expectations are those from <code>HttpResponseExpectation</code>:</p> <pre><code>Future&lt;JsonObject&gt; future = client\n    .request(HttpMethod.GET, \"some-uri\")\n    .compose(request -&gt; request\n        .send()\n        .expecting(HttpResponseExpectation.SC_OK.and(HttpResponseExpectation.JSON))\n    .compose(response -&gt; response\n        .body()\n        .map(buffer -&gt; buffer.toJsonObject())));\n</code></pre> <p>In this example the HTTP response is expected to be with status code 200 (<code>SC_OK</code>) and have the <code>application/json</code> content-type (<code>JSON</code>).</p>"},{"location":"using-vertx-expectations/#where-are-expectations-gone-in-a-vertx-mutiny-bindings-api","title":"Where are expectations gone in a Vert.x Mutiny bindings API?","text":"<p>While expectations are very useful, they apply to <code>Future</code> in most of the Vert.x APIs such as the core HTTP client.</p> <p>Since the Mutiny bindings generator turns <code>Future</code>-returning methods into <code>Uni</code>-returning methods, you need to leverage another route to use them.</p>"},{"location":"using-vertx-expectations/#turning-expectations-into-operators","title":"Turning expectations into operators","text":"<p>The <code>io.smallrye.mutiny.vertx.core.Expectations</code> class that comes with the <code>smallrye-mutiny-vertx-core</code> artifact bring 2 helper methods.</p> <p>The <code>expecting</code> methods build functions that can be used with the <code>Uni::plug</code> operator, as in:</p> <pre><code>Expectation&lt;Integer&gt; tenToTwenty = (value -&gt; value &gt;= 10 &amp;&amp; value &lt;= 20);\n\nreturn Uni.createFrom().item(15)\n    .plug(expectation(tenToTwenty));\n</code></pre> <p>Some expectations such as those in <code>HttpResponseExpectation</code> apply to types from the core Vert.x APIs. Since the Mutiny bindings generate shims (e.g., <code>io.vertx.mutiny.core.http.HttpResponseHead</code>), you need to extract the delegate type for the expectations to work on the correct type (e.g., <code>io.vertx.core.http.HttpResponseHead</code>):</p> <pre><code>return vertx.createHttpClient()\n    .request(HttpMethod.GET, port, \"localhost\", \"/\")\n    .chain(HttpClientRequest::send)\n    .plug(expectation(HttpClientResponse::getDelegate, status(200).and(contentType(\"text/plain\"))))\n    .onItem().transformToUni(HttpClientResponse::body)\n</code></pre> <p>The extractor function here is <code>HttpClientResponse::getDelegate</code>, so that the <code>status(200).and(contentType(\"text/plain\"))</code> expectation applies to <code>io.vertx.core.http.HttpResponseHead</code> and not the <code>io.vertx.mutiny.core.http.HttpResponseHead</code> generated shim.</p>"},{"location":"apidocs/legal/jquery/","title":"Jquery","text":""},{"location":"apidocs/legal/jquery/#jquery-v371","title":"jQuery v3.7.1","text":""},{"location":"apidocs/legal/jquery/#jquery-license","title":"jQuery License","text":"<pre><code>jQuery v 3.7.1\nCopyright OpenJS Foundation and other contributors, https://openjsf.org/\n\nPermission is hereby granted, free of charge, to any person obtaining\na copy of this software and associated documentation files (the\n\"Software\"), to deal in the Software without restriction, including\nwithout limitation the rights to use, copy, modify, merge, publish,\ndistribute, sublicense, and/or sell copies of the Software, and to\npermit persons to whom the Software is furnished to do so, subject to\nthe following conditions:\n\nThe above copyright notice and this permission notice shall be\nincluded in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\nNONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\nLIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\nOF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\nWITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n</code></pre>"},{"location":"apidocs/legal/jqueryUI/","title":"jqueryUI","text":""},{"location":"apidocs/legal/jqueryUI/#jquery-ui-v1132","title":"jQuery UI v1.13.2","text":""},{"location":"apidocs/legal/jqueryUI/#jquery-ui-license","title":"jQuery UI License","text":"<pre><code>Copyright jQuery Foundation and other contributors, https://jquery.org/\n\nThis software consists of voluntary contributions made by many\nindividuals. For exact contribution history, see the revision history\navailable at https://github.com/jquery/jquery-ui\n\nThe following license applies to all parts of this software except as\ndocumented below:\n\n====\n\nPermission is hereby granted, free of charge, to any person obtaining\na copy of this software and associated documentation files (the\n\"Software\"), to deal in the Software without restriction, including\nwithout limitation the rights to use, copy, modify, merge, publish,\ndistribute, sublicense, and/or sell copies of the Software, and to\npermit persons to whom the Software is furnished to do so, subject to\nthe following conditions:\n\nThe above copyright notice and this permission notice shall be\nincluded in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\nNONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\nLIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\nOF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\nWITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n====\n\nCopyright and related rights for sample code are waived via CC0. Sample\ncode is defined as all source code contained within the demos directory.\n\nCC0: http://creativecommons.org/publicdomain/zero/1.0/\n\n====\n\nAll files located in the node_modules and external directories are\nexternally maintained libraries used by this software which have their\nown licenses; we recommend you read them, as their terms may differ from\nthe terms above.\n</code></pre>"}]}